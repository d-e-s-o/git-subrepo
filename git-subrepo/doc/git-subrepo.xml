<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>
<refentry>
<refmeta>
<refentrytitle>git-subrepo</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class="source">Git</refmiscinfo>
<refmiscinfo class="manual">Git Manual</refmiscinfo>
</refmeta>
<refnamediv>
  <refname>git-subrepo</refname>
  <refpurpose>Import a subrepo</refpurpose>
</refnamediv>
<refsynopsisdiv id="_synopsis">
<literallayout><emphasis>git subrepo</emphasis> import [--edit] [--verbose] &lt;remote-repository&gt; &lt;prefix&gt; &lt;commit&gt;</literallayout>
<simpara></simpara>
</refsynopsisdiv>
<refsect1 id="_description">
<title>DESCRIPTION</title>
<simpara>Imports a subrepo at a given prefix representing a given commit.</simpara>
<simpara>A subrepo allows you to keep another Git repository in a subdirectory
of your current repository (the current repository is termed the
"superrepo"). The other repository&#8217;s source code is thereby embedded
directly into this repository. This embedding makes subrepos preferable
to submodules (see <citerefentry>
<refentrytitle>git-submodule</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>) in many scenarios, as
references to another repository cannot become invalid and all
dependencies required in the superrepo are contained in it. In that
sense, subrepos behave similar to subtrees (see <citerefentry>
<refentrytitle>git-subtree</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>)
when using the --squash option to squash commits. The resulting commit,
however, is not a merge in any way. Rather, the source code is imported
as a "normal" commit, allowing for rebasing to take place, for instance.</simpara>
<simpara>Being part of the superrepo, clone and pull operations will involve any
subrepos equally well, without any additional command invocations being
required.</simpara>
</refsect1>
<refsect1 id="_commands">
<title>COMMANDS</title>
<variablelist>
<varlistentry>
<term>
import
</term>
<listitem>
<simpara>
  Import the given remote repository as a subrepo at the given
  prefix/path in the state as specified by the given commit. A new
  commit will be created in the superrepo that imports the source code.
  This command handles initial additions as well as incremental updates.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</refsect1>
<refsect1 id="_options">
<title>OPTIONS</title>
<variablelist>
<varlistentry>
<term>
&lt;remote-repository&gt;
</term>
<listitem>
<simpara>
  Name of a remote repository to import in the form of a subrepo. The
  remote repository should be up-to-date such that the given commit is
  known locally. Please refer to <citerefentry>
<refentrytitle>git-remote</refentrytitle><manvolnum>1</manvolnum>
</citerefentry> for more details
  on remote repositories.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
&lt;prefix&gt;
</term>
<listitem>
<simpara>
  Relative path specifying where to import a subrepo. If code exists at
  the given prefix the differences to reach the desired state of the
  specified remote repository will be applied on top.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
&lt;commit&gt;
</term>
<listitem>
<simpara>
  Commit representing the state at which to import the given remote
  repository as a subrepo or to which to update the given subrepo to.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-e
</term>
<term>
--edit
</term>
<listitem>
<simpara>
  By default git-subrepo creates a commit message containing only the
  essential information for a particular commit. When this option is set
  the committer gets the chance to further edit the message.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-v
</term>
<term>
--verbose
</term>
<listitem>
<simpara>
  In normal mode of operation git-subrepo only prints messages in case
  of errors. For debugging purposes it might be beneficial to understand
  which commands are being executed and possibly replay them. By
  specifying this option all command invocations are reported to the
  user.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</refsect1>
<refsect1 id="_root_imports">
<title>ROOT IMPORTS</title>
<simpara>One advantage of subrepos over git&#8217;s native submodules is the fact that
the source code of the destination is embedded in the repository. The
ability to have ordinary commits as opposed to merges as they are
created when subtrees are in use is beneficial for rebasing over
imports.</simpara>
<simpara>However, there is another feature that is unique to subrepos: the
ability to import remote repositories directly into the root directory
of the owning repository. Consider the following example:</simpara>
<literallayout class="monospaced">lib1
└── src
    └── lib1.py</literallayout>
<literallayout class="monospaced">lib2
└── src
    ├── lib1
    │   └── src
    │       └── lib1.py
    └── lib2.py</literallayout>
<simpara>In this example we have two libraries, <emphasis>lib1</emphasis> and <emphasis>lib2</emphasis>. The latter
depends on the former and, hence, imports it in the form of a subrepo.
Now imagine an application, <emphasis>app</emphasis>, using <emphasis>lib2</emphasis>. Once <emphasis>app</emphasis> imports
<emphasis>lib2</emphasis> it will implicitly import <emphasis>lib1</emphasis> as well (which is intended
because it is an implicit dependency).</simpara>
<literallayout class="monospaced">app
└── src
    ├── app.py
    └── lib2
        └── src
            ├── lib1
            │   └── src
            │       └── lib1.py
            └── lib2.py</literallayout>
<simpara>With each import the level of nesting increases. Not only that, there is
also a non-uniformity in the directory layout: the source code in the
owning repository is scattered counter-intuitively over different
directory levels, making it unnecessarily complex to find files. These
problems are inherent the moment a repository starts having
subdirectories.
Such problems vanish when we restructure the repositories slightly and
then import each directly into the owning repository&#8217;s root directory,
like so:</simpara>
<literallayout class="monospaced">lib1
└── lib1
    └── src
        └── lib1.py</literallayout>
<literallayout class="monospaced">lib2
├── lib1
│   └── src
│       └── lib1.py
└── lib2
    └── src
        └── lib2.py</literallayout>
<literallayout class="monospaced">app
├── app
│   └── src
│       └── app.py
├── lib1
│   └── src
│       └── lib1.py
└── lib2
    └── src
        └── lib2.py</literallayout>
<simpara>Now an interesting question arises: since the root name space of the
owning repository is shared, how are conflicts handled? The answer is
simple: the last import will take precedence and applied are the changes
from the current state of the owning repository to one where the subrepo
to import is at the desired state.</simpara>
<simpara>This approach also solves another otherwise inherent problem, namely
that if each subrepo pulls in its dependencies and two subrepos have the
same dependency, the source code of this last dependency will reside in
the repository at two places. From a logical point of view that is not
necessary a problem. However, if one considers how the module systems of
a variety of languages or their compilers/interpreters work it becomes
apparent that one of the two is effectively dead code: the path to each
subrepo has to be registered somewhere and this path will be searched
for a match during compile or run time. Yet, only the first match that
is found is used. This constraint in turn implies that both versions of
the subrepo need to be "compatible" if they are to be used in a common
application and we must be able to agree on using a single version.</simpara>
<simpara>Extending the example from before with a third library, <emphasis>lib3</emphasis> that
depends on <emphasis>lib1</emphasis> as well, and making <emphasis>app</emphasis> require <emphasis>lib3</emphasis> in addition
to <emphasis>lib2</emphasis>, we get away with the following structure:</simpara>
<literallayout class="monospaced">app
├── app
│   └── src
│       └── app.py
├── lib1
│   └── src
│       └── lib1.py
├── lib2
│   └── src
│       └── lib2.py
└── lib3
    └── src
        └── lib3.py</literallayout>
<simpara>Here, <emphasis>lib1</emphasis> is used by both <emphasis>lib2</emphasis> and <emphasis>lib3</emphasis> without the need to have
a private copy in each. By design, it must be compatible with both.</simpara>
</refsect1>
<refsect1 id="_git">
<title>GIT</title>
<simpara>To be used in conjunction with the <citerefentry>
<refentrytitle>git</refentrytitle><manvolnum>1</manvolnum>
</citerefentry> suite</simpara>
</refsect1>
</refentry>
